"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
var utils_1 = require("./utils");
var Container = /** @class */ (function () {
    function Container(options) {
        if (options === void 0) { options = []; }
        this.instances = {};
        this.addInstances(options);
    }
    Container.verifyOptions = function (options) {
        var _this = this;
        if (!Array.isArray(options)) {
            throw new Error('options should be an array');
        }
        options.forEach(function (option) {
            if (!(0, utils_1.isObject)(option) || Array.isArray(option)) {
                throw new Error('options item should be an instance option object');
            }
            var keys = Object.keys(option);
            var allowedProps = ['key', 'Class', 'parameter'];
            var unknownProps = keys.filter(function (key) { return !allowedProps.includes(key); });
            if (unknownProps.length) {
                throw new Error("".concat(unknownProps.join(', '), " not allowed in instance option"));
            }
            if (!keys.includes('Class')) {
                throw new Error('instance option should contain Class to be create later on');
            }
            // @ts-ignore
            if (typeof option.Class !== 'function' && typeof option.Class.name !== 'string') {
                throw new Error('Class should be a class or constructor function');
            }
            if (option.parameter) {
                _this.verifyParameterOption(option.parameter);
            }
        });
    };
    Container.verifyParameterOption = function (optionParameter) {
        if (!(0, utils_1.isObject)(optionParameter) || Array.isArray(optionParameter)) {
            throw new Error('parameter should be a ParameterOption object');
        }
        var keys = Object.keys(optionParameter);
        var allowedProps = ['injectType', 'dependencies'];
        var unknownProps = keys.filter(function (key) { return !allowedProps.includes(key); });
        if (unknownProps.length) {
            throw new Error("".concat(unknownProps.join(', '), " is not allowed in parameter option"));
        }
        if (optionParameter.injectType) {
            var allowedValue = ['parameter', 'destructuring'];
            if (!allowedValue.includes(optionParameter.injectType)) {
                throw new Error("parameter inject type should be ".concat(allowedValue.join(' or ')));
            }
            if (optionParameter.dependencies) {
                if (optionParameter.injectType === 'destructuring') {
                    this.verifyDestructuringDependencies(optionParameter.dependencies);
                    return;
                }
                this.verifyParameterDependencies(optionParameter.dependencies);
            }
        }
    };
    Container.verifyDestructuringDependencies = function (dependencies) {
        if (!Array.isArray(dependencies)) {
            throw new Error('dependencies should be an array');
        }
        dependencies.forEach(function (dependency) {
            if (!(0, utils_1.isObject)(dependency) || Array.isArray(dependency)) {
                throw new Error('dependencies item should be a Dependency object');
            }
            var keys = Object.keys(dependency);
            var allowedProps = ['name', 'concrete', 'internal'];
            var unknownProps = keys.filter(function (key) { return !allowedProps.includes(key); });
            if (unknownProps.length) {
                throw new Error("".concat(unknownProps.join(', '), " is not allowed in Dependency object"));
            }
            if (!dependency.name) {
                throw new Error('dependency should contain name when using destructuring inject type');
            }
            if (typeof dependency.name !== 'string') {
                throw new Error('dependency name should be a string');
            }
            if (dependency.concrete && dependency.internal) {
                throw new Error('cannot define concrete and internal together');
            }
            if (!dependency.concrete && !dependency.internal) {
                throw new Error('please define dependency in concrete or internal');
            }
            if (dependency.internal && typeof dependency.internal !== 'string') {
                throw new Error('internal property only accept string');
            }
        });
    };
    Container.verifyParameterDependencies = function (dependencies) {
        if (!Array.isArray(dependencies)) {
            throw new Error('dependencies should be an array');
        }
        dependencies.forEach(function (dependency) {
            if (!(0, utils_1.isObject)(dependency) || Array.isArray(dependency)) {
                throw new Error('dependencies item should be a dependency object');
            }
            if (dependency.name) {
                throw new Error('no need to define name when using parameter inject type');
            }
            var keys = Object.keys(dependency);
            var allowedProps = ['concrete', 'internal'];
            var unknownProps = keys.filter(function (key) { return !allowedProps.includes(key); });
            if (unknownProps.length) {
                throw new Error("".concat(unknownProps.join(', '), " is not allowed in dependency object"));
            }
            if (dependency.concrete && dependency.internal) {
                throw new Error('cannot define concrete and internal together');
            }
            if (!dependency.concrete && !dependency.internal) {
                throw new Error('please define dependency in concrete or internal');
            }
            if (dependency.internal && typeof dependency.internal !== 'string') {
                throw new Error('internal property only accept string');
            }
        });
    };
    Container.prototype.addInstances = function (options) {
        var _this = this;
        Container.verifyOptions(options);
        options.forEach(function (option) {
            var Class = option.Class, _a = option.parameter, parameter = _a === void 0 ? { injectType: 'parameter', dependencies: [] } : _a;
            var _b = option.key, key = _b === void 0 ? Class.name : _b;
            if (!parameter.injectType) {
                parameter.injectType = 'parameter';
            }
            if (!parameter.dependencies) {
                parameter.dependencies = [];
            }
            _this.instances[key] = { key: key, Class: Class, parameter: parameter };
        });
    };
    Container.prototype.getInstance = function (key) {
        var _a;
        var instance = this.instances[key];
        if (!instance) {
            throw new Error("".concat(key, " instance not found"));
        }
        if (instance.INSTANCE instanceof instance.Class) {
            return instance.INSTANCE;
        }
        var parameters = this.buildParameters(instance.parameter);
        instance.INSTANCE = Array.isArray(parameters)
            ? new ((_a = instance.Class).bind.apply(_a, __spreadArray([void 0], parameters, false)))() : new instance.Class(parameters);
        return instance.INSTANCE;
    };
    Container.prototype.destroyInstance = function (key) {
        if (!this.instances[key]) {
            throw new Error("Cannot destroy instance with key ".concat(key, ". Because it is not exist"));
        }
        delete this.instances[key].INSTANCE;
    };
    Container.prototype.destroyAllInstances = function () {
        var _this = this;
        Object.keys(this.instances).forEach(function (key) { return delete _this.instances[key].INSTANCE; });
    };
    Container.prototype.register = function (options) {
        var instancesToAdd = Array.isArray(options) ? options : [options];
        this.addInstances(instancesToAdd);
    };
    Container.prototype.buildParameters = function (parameter) {
        var _this = this;
        if (parameter.injectType === 'destructuring') {
            var deps_1 = {};
            var dependencies_1 = parameter.dependencies;
            // Build destructuring params
            dependencies_1.forEach(function (dependency) {
                if (dependency.concrete) {
                    deps_1[dependency.name] = dependency.concrete;
                    return;
                }
                deps_1[dependency.name] = _this.getInstance(dependency.internal);
            });
            return deps_1;
        }
        // Build normal parameters
        var deps = [];
        var dependencies = parameter.dependencies;
        dependencies.forEach(function (dependency, index) {
            if (dependency.concrete) {
                deps[index] = dependency.concrete;
                return;
            }
            deps[index] = _this.getInstance(dependency.internal);
        });
        return deps;
    };
    return Container;
}());
exports.Container = Container;
