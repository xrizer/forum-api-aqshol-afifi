"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Container_1 = require("../Container");
describe('Container', function () {
    describe('verify instance options', function () {
        it('should throw error when instance option not array', function () {
            expect(function () { return new Container_1.Container({}); }).toThrowError('options should be an array');
        });
        it('should throw error when option item not an object', function () {
            expect(function () { return new Container_1.Container(['string', 1, {}]); }).toThrowError('options item should be an instance option object');
            expect(function () { return new Container_1.Container([null, {}, {}]); }).toThrowError('options item should be an instance option object');
        });
        it('should throw error when instance option contain unknown property', function () {
            var instanceOptions = [
                {
                    key: 'class a',
                    Class: /** @class */ (function () {
                        function Class() {
                        }
                        return Class;
                    }()),
                    parameter: {},
                    otherProps: {},
                    otherProps2: {},
                    otherProps3: {},
                },
            ];
            expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('otherProps, otherProps2, otherProps3 not allowed in instance option');
        });
        it('should throw error when instance option not contain Class property', function () {
            var instanceOptions = [
                {
                    key: 'class a',
                    parameter: {},
                },
            ];
            expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('instance option should contain Class to be create later on');
        });
        it('should throw error when instance option Class is not constructor function', function () {
            var instanceOptions = [
                {
                    key: 'class a',
                    Class: {},
                    parameter: {},
                },
            ];
            expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('Class should be a class or constructor function');
        });
        describe('when instance option parameter defined', function () {
            it('should throw error when parameter is not an object', function () {
                var instanceOptions = [
                    {
                        key: 'class a',
                        Class: /** @class */ (function () {
                            function Class() {
                            }
                            return Class;
                        }()),
                        parameter: [],
                    },
                    {
                        key: 'class b',
                        Class: /** @class */ (function () {
                            function b() {
                            }
                            return b;
                        }()),
                        parameter: 'param',
                    },
                ];
                expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('parameter should be a ParameterOption object');
            });
            it('should throw error when parameter is contain unknown property', function () {
                var instanceOptions = [
                    {
                        key: 'class a',
                        Class: /** @class */ (function () {
                            function Class() {
                            }
                            return Class;
                        }()),
                        parameter: {
                            injectType: 'parameter',
                            dependencies: [],
                            unknownA: {},
                            unknownB: {},
                        },
                    },
                ];
                expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('unknownA, unknownB is not allowed in parameter option');
            });
            describe('when injectType is defined', function () {
                it('should throw error when value is not allowed value', function () {
                    var instanceOptions = [
                        {
                            key: 'class a',
                            Class: /** @class */ (function () {
                                function Class() {
                                }
                                return Class;
                            }()),
                            parameter: {
                                injectType: true,
                            },
                        },
                    ];
                    expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('parameter inject type should be parameter or destructuring');
                });
                describe('when dependencies is defined and injectType is destructuring', function () {
                    it('should throw error when value is not an array', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'destructuring',
                                    dependencies: {},
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('dependencies should be an array');
                    });
                    it('should throw error when dependencies item is not an object', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'destructuring',
                                    dependencies: [true, 'a'],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('dependencies item should be a Dependency object');
                    });
                    it('should throw error when dependency is contain unknown property', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'destructuring',
                                    dependencies: [
                                        {
                                            name: 'objA',
                                            concrete: {},
                                            unknownA: {},
                                            unknownB: {},
                                        },
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('unknownA, unknownB is not allowed in Dependency object');
                    });
                    it('should throw error when dependency is not contain name property', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'destructuring',
                                    dependencies: [
                                        {
                                            concrete: {},
                                        },
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('dependency should contain name when using destructuring inject type');
                    });
                    it('should throw error when dependency name is not string', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'destructuring',
                                    dependencies: [
                                        {
                                            name: true,
                                            concrete: {},
                                        },
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('dependency name should be a string');
                    });
                    it('should throw error when define concrete and internal together', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'destructuring',
                                    dependencies: [
                                        {
                                            name: 'class a',
                                            concrete: {},
                                            internal: 'class b',
                                        },
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('cannot define concrete and internal together');
                    });
                    it('should throw error when concrete or internal not defined', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'destructuring',
                                    dependencies: [
                                        {
                                            name: 'class a',
                                        },
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('please define dependency in concrete or internal');
                    });
                    describe('when internal is defined', function () {
                        it('should throw error if not string', function () {
                            var instanceOptions = [
                                {
                                    key: 'class a',
                                    Class: /** @class */ (function () {
                                        function Class() {
                                        }
                                        return Class;
                                    }()),
                                    parameter: {
                                        injectType: 'destructuring',
                                        dependencies: [
                                            {
                                                name: 'class a',
                                                internal: 123,
                                            },
                                        ],
                                    },
                                },
                            ];
                            expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('internal property only accept string');
                        });
                    });
                });
                describe('when dependencies is defined and injectType is parameter', function () {
                    it('should throw error when value is not an array', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'parameter',
                                    dependencies: {},
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('dependencies should be an array');
                    });
                    it('should throw error when dependencies item is not an object', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'parameter',
                                    dependencies: [true, 'a'],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('dependencies item should be a dependency object');
                    });
                    it('should throw error when dependency define a name', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'parameter',
                                    dependencies: [
                                        {
                                            name: 'objA',
                                            concrete: {},
                                        },
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('no need to define name when using parameter inject type');
                    });
                    it('should throw error when dependency is contain unknown property', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'parameter',
                                    dependencies: [
                                        {
                                            concrete: {},
                                            unknownA: {},
                                            unknownB: {},
                                        },
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('unknownA, unknownB is not allowed in dependency object');
                    });
                    it('should throw error when define concrete and internal together', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'parameter',
                                    dependencies: [
                                        {
                                            concrete: {},
                                            internal: 'class b',
                                        },
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('cannot define concrete and internal together');
                    });
                    it('should throw error when concrete or internal not defined', function () {
                        var instanceOptions = [
                            {
                                key: 'class a',
                                Class: /** @class */ (function () {
                                    function Class() {
                                    }
                                    return Class;
                                }()),
                                parameter: {
                                    injectType: 'parameter',
                                    dependencies: [
                                        {},
                                    ],
                                },
                            },
                        ];
                        expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('please define dependency in concrete or internal');
                    });
                    describe('when internal is defined', function () {
                        it('should throw error if not string', function () {
                            var instanceOptions = [
                                {
                                    key: 'class a',
                                    Class: /** @class */ (function () {
                                        function Class() {
                                        }
                                        return Class;
                                    }()),
                                    parameter: {
                                        injectType: 'parameter',
                                        dependencies: [
                                            {
                                                internal: 123,
                                            },
                                        ],
                                    },
                                },
                            ];
                            expect(function () { return new Container_1.Container(instanceOptions); }).toThrowError('internal property only accept string');
                        });
                    });
                });
            });
        });
    });
    describe('initialize', function () {
        it('should initialize instances correctly when not defined options', function () {
            var container = new Container_1.Container();
            expect(container).toBeInstanceOf(Container_1.Container);
        });
        it('should initialize instances correctly when not defined key in parameter options', function () {
            var options = [
                {
                    Class: /** @class */ (function () {
                        function Car() {
                        }
                        return Car;
                    }()),
                },
            ];
            var container = new Container_1.Container(options);
            expect(container.instances.Car).toBeInstanceOf(Object);
            expect(container.instances.Car.key).toBe('Car');
            expect(container.instances.Car.Class).toEqual(options[0].Class);
        });
        it('should initialize instances correctly when defined key in parameter options', function () {
            var options = [
                {
                    key: 'CarA',
                    Class: /** @class */ (function () {
                        function Car() {
                        }
                        return Car;
                    }()),
                },
            ];
            var container = new Container_1.Container(options);
            expect(container.instances.CarA).toBeInstanceOf(Object);
            expect(container.instances.CarA.key).toBe('CarA');
            expect(container.instances.CarA.Class).toEqual(options[0].Class);
        });
        it('should initialize instances correctly when parameter object not defined', function () {
            var options = [
                {
                    key: 'CarA',
                    Class: /** @class */ (function () {
                        function Car() {
                        }
                        return Car;
                    }()),
                },
            ];
            var container = new Container_1.Container(options);
            expect(container.instances.CarA.parameter).toEqual({
                injectType: 'parameter',
                dependencies: [],
            });
        });
        it('should initialize instances correctly when parameter object is defined with empty object', function () {
            var options = [
                {
                    key: 'CarA',
                    Class: /** @class */ (function () {
                        function Car() {
                        }
                        return Car;
                    }()),
                    parameter: {},
                },
            ];
            var container = new Container_1.Container(options);
            expect(container.instances.CarA.parameter).toEqual({
                injectType: 'parameter',
                dependencies: [],
            });
        });
        it('should initialize instances correctly when parameter object is only defined dependencies', function () {
            var options = [
                {
                    key: 'CarA',
                    Class: /** @class */ (function () {
                        function Car() {
                        }
                        return Car;
                    }()),
                    parameter: {
                        dependencies: [
                            {
                                concrete: {},
                            },
                        ],
                    },
                },
            ];
            var container = new Container_1.Container(options);
            expect(container.instances.CarA.parameter).toEqual({
                injectType: 'parameter',
                dependencies: [
                    {
                        concrete: {},
                    },
                ],
            });
        });
        it('should initialize instances correctly when injectType is destructuring', function () {
            var options = [
                {
                    key: 'CarA',
                    Class: /** @class */ (function () {
                        function Car() {
                        }
                        return Car;
                    }()),
                    parameter: {
                        injectType: 'destructuring',
                    },
                },
            ];
            var container = new Container_1.Container(options);
            expect(container.instances.CarA.parameter).toEqual({
                injectType: 'destructuring',
                dependencies: [],
            });
        });
        it('should initialize instances correctly when given multiple instances options', function () {
            var options = [
                {
                    key: 'CarA',
                    Class: /** @class */ (function () {
                        function Car() {
                        }
                        return Car;
                    }()),
                    parameter: {
                        injectType: 'destructuring',
                    },
                },
                {
                    key: 'CarB',
                    Class: /** @class */ (function () {
                        function Car() {
                        }
                        return Car;
                    }()),
                    parameter: {
                        injectType: 'parameter',
                        dependencies: [
                            {
                                concrete: {},
                            },
                        ],
                    },
                },
            ];
            var container = new Container_1.Container(options);
            expect(JSON.stringify(container.instances.CarA)).toEqual(JSON.stringify({
                key: 'CarA',
                Class: /** @class */ (function () {
                    function Car() {
                    }
                    return Car;
                }()),
                parameter: {
                    injectType: 'destructuring',
                    dependencies: [],
                },
            }));
            expect(JSON.stringify(container.instances.CarB)).toEqual(JSON.stringify({
                key: 'CarB',
                Class: /** @class */ (function () {
                    function Car() {
                    }
                    return Car;
                }()),
                parameter: {
                    injectType: 'parameter',
                    dependencies: [
                        {
                            concrete: {},
                        },
                    ],
                },
            }));
        });
    });
    describe('getInstance', function () {
        var container;
        beforeEach(function () {
            var instanceOptions = [
                {
                    Class: /** @class */ (function () {
                        function Engine(petrol) {
                            this.petrol = petrol;
                        }
                        return Engine;
                    }()),
                    parameter: {
                        dependencies: [
                            {
                                concrete: {}, // dummy petrol
                            },
                        ],
                    },
                },
                {
                    Class: /** @class */ (function () {
                        function Car(_a) {
                            var engine = _a.engine, doorCount = _a.doorCount;
                            this.engine = engine;
                            this.doorCount = doorCount;
                        }
                        return Car;
                    }()),
                    parameter: {
                        injectType: 'destructuring',
                        dependencies: [
                            {
                                name: 'engine',
                                internal: 'Engine',
                            },
                            {
                                name: 'doorCount',
                                concrete: 4,
                            },
                        ],
                    },
                },
                {
                    Class: /** @class */ (function () {
                        function Motorcycle(engine, isMatic) {
                            this.engine = engine;
                            this.isMatic = isMatic;
                        }
                        return Motorcycle;
                    }()),
                    parameter: {
                        dependencies: [
                            {
                                internal: 'Engine',
                            },
                            {
                                concrete: true,
                            },
                        ],
                    },
                },
            ];
            container = new Container_1.Container(instanceOptions);
        });
        it('should get instance correctly', function () {
            var car = container.getInstance('Car');
            var bike = container.getInstance('Motorcycle');
            expect(car).toBeInstanceOf(container.instances.Car.Class);
            expect(car.doorCount).toEqual(4);
            expect(car.engine).toBeInstanceOf(container.instances.Engine.Class);
            expect(bike).toBeInstanceOf(container.instances.Motorcycle.Class);
            expect(bike.isMatic).toEqual(true);
            expect(bike.engine).toBeInstanceOf(container.instances.Engine.Class);
        });
        it('should throw error when instance not found', function () {
            expect(function () { return container.getInstance('abc'); })
                .toThrow('abc instance not found');
        });
        it('should only create one instance (singleton)', function () {
            var car1 = container.getInstance('Car');
            var car2 = container.getInstance('Car');
            expect(car1 === car2).toBe(true);
        });
        it('should create instance only when needed (lazy)', function () {
            expect(container.instances.Car.INSTANCE).toBe(undefined);
            expect(container.instances.Engine.INSTANCE).toBe(undefined);
            container.getInstance('Car');
            expect(container.instances.Car.INSTANCE)
                .toBeInstanceOf(container.instances.Car.Class);
            expect(container.instances.Engine.INSTANCE)
                .toBeInstanceOf(container.instances.Engine.Class);
        });
    });
    describe('destroyInstance', function () {
        var container;
        beforeEach(function () {
            var instanceOptions = [
                {
                    Class: /** @class */ (function () {
                        function Engine(petrol) {
                            this.petrol = petrol;
                        }
                        return Engine;
                    }()),
                    parameter: {
                        dependencies: [
                            {
                                concrete: {}, // dummy petrol
                            },
                        ],
                    },
                },
            ];
            container = new Container_1.Container(instanceOptions);
        });
        it('should throw error when instance is not found', function () {
            expect(function () { return container.destroyInstance('not_found'); })
                .toThrowError('Cannot destroy instance with key not_found. Because it is not exist');
        });
        it('should delete active instance correctly', function () {
            container.getInstance('Engine');
            expect(container.instances.Engine.INSTANCE)
                .toBeInstanceOf(container.instances.Engine.Class);
            container.destroyInstance('Engine');
            expect(container.instances.Engine.INSTANCE).toEqual(undefined);
        });
    });
    describe('destroyAllInstances', function () {
        var container;
        beforeEach(function () {
            var instanceOptions = [
                {
                    Class: /** @class */ (function () {
                        function Engine(petrol) {
                            this.petrol = petrol;
                        }
                        return Engine;
                    }()),
                    parameter: {
                        dependencies: [
                            {
                                concrete: {}, // dummy petrol
                            },
                        ],
                    },
                },
                {
                    Class: /** @class */ (function () {
                        function Car(_a) {
                            var engine = _a.engine, doorCount = _a.doorCount;
                            this.engine = engine;
                            this.doorCount = doorCount;
                        }
                        return Car;
                    }()),
                    parameter: {
                        injectType: 'destructuring',
                        dependencies: [
                            {
                                name: 'engine',
                                internal: 'Engine',
                            },
                            {
                                name: 'doorCount',
                                concrete: 4,
                            },
                        ],
                    },
                },
            ];
            container = new Container_1.Container(instanceOptions);
        });
        it('should destroy all active instance', function () {
            container.getInstance('Car');
            expect(container.instances.Engine.INSTANCE)
                .toBeInstanceOf(container.instances.Engine.Class);
            expect(container.instances.Car.INSTANCE)
                .toBeInstanceOf(container.instances.Car.Class);
            container.destroyAllInstances();
            expect(container.instances.Engine.INSTANCE).toBe(undefined);
            expect(container.instances.Car.INSTANCE).toBe(undefined);
        });
    });
    describe('register', function () {
        it('should register class correctly when only given a single instance option', function () {
            var container = new Container_1.Container();
            var Engine = /** @class */ (function () {
                function Engine() {
                }
                return Engine;
            }());
            container.register({ Class: Engine });
            expect(container.instances.Engine.Class).toEqual(Engine);
            expect(container.instances.Engine.key).toEqual('Engine');
        });
        it('should register class correctly when given a multiple instance option', function () {
            var container = new Container_1.Container();
            var Engine = /** @class */ (function () {
                function Engine() {
                }
                return Engine;
            }());
            var Oil = /** @class */ (function () {
                function Oil() {
                }
                return Oil;
            }());
            container.register([{ Class: Engine }, { Class: Oil }]);
            expect(container.instances.Engine.Class).toEqual(Engine);
            expect(container.instances.Engine.key).toEqual('Engine');
            expect(container.instances.Oil.Class).toEqual(Oil);
            expect(container.instances.Oil.key).toEqual('Oil');
        });
    });
});
